# Document Processing Pipeline Application

This application provides a web interface for processing documents through a series of models and generating reports.

## Dockerizing the Application

This section explains how to build and run the application using Docker.

### Prerequisites

- Docker installed on your system. (https://www.docker.com/get-started)

### Building the Docker Image

1.  Navigate to the `Src/deploy` directory of the project (where the `Dockerfile` is located).
2.  Run the following command in your terminal to build the Docker image:

    ```bash
    docker build -t document-processor-app .
    ```
    You can replace `document-processor-app` with your preferred image name.

### Running the Docker Container

1.  Once the image is built, you can run the application in a Docker container:

    ```bash
    docker run --rm -p 5001:5001 \
      -v "$(pwd)/outputs":/app/outputs \
      -v "$(pwd)/models":/app/models \
      document-processor-app
    ```
    - `--rm`: Automatically removes the container when it exits.
    - `-p 5001:5001`: Maps port 5001 of the container to port 5001 on your host machine.
    - `-v "$(pwd)/outputs":/app/outputs`: Mounts the local `outputs` directory (from your current directory on the host) into the container's `/app/outputs` directory. This allows reports generated by the application to persist on your host machine and be accessible even after the container stops.
    - `-v "$(pwd)/models":/app/models`: Mounts the local `models` directory into the container's `/app/models` directory. This allows the application to access model files from your host, which is useful if your models are large or updated frequently.
    - `document-processor-app`: The name of the Docker image you built.

2.  The application will be accessible in your web browser at `http://localhost:5001`.

## GitLab CI/CD Integration

This section provides an example of how to integrate the Dockerized application into a GitLab CI/CD pipeline.

### `.gitlab-ci.yml` Example

Create a `.gitlab-ci.yml` file in the root of your GitLab repository with content similar to the following. This example assumes your repository structure includes `Src/deploy/` (where the `Dockerfile` and application code reside), `Src/Model/OCR_Classification/Model/` (for the OCR test), and `Documentation/` (for LaTeX files).

```yaml
stages:
  - build_docs          # For LaTeX documentation
  - build_app_image     # For the main application Docker image
  - model_processing    # Combined stage for model steps for simplicity, or keep separate
  - test
  - deploy

variables:
  # Using GitLab's predefined variables for the container registry
  IMAGE_NAME: $CI_REGISTRY_IMAGE/document-processor-app
  IMAGE_TAG: $CI_COMMIT_REF_SLUG
  FULL_IMAGE_NAME: $IMAGE_NAME:$IMAGE_TAG
  # For non-GitLab registry, you might need DOCKER_HUB_USERNAME, DOCKER_HUB_PASSWORD, etc.

build_documentation:
  stage: build_docs
  image: danteev/texlive
  script:
    - |
      if [ -d "Documentation" ]; then
        cd Documentation
        echo "Attempting to build LaTeX documents..."
        for file in *.tex; do 
          if [ -f "$file" ]; then
            echo "Building $file..."
            latexmk -pdf "$file"
          else
            echo "No .tex files found in Documentation directory."
            break # Exit loop if no .tex files
          fi
        done
        # Check if PDFs were created
        if ls *.pdf 1> /dev/null 2>&1; then
          echo "PDFs created successfully."
        else
          echo "No PDFs were created."
        fi
      else
        echo "Documentation directory not found. Skipping PDF generation."
      fi
  artifacts:
    paths:
      - Documentation/*.pdf
    expire_in: 1 week
    when: always # Attempt to save artifacts even if the script has issues (e.g., no .tex files)

build_application_image:
  stage: build_app_image
  image: docker:20.10.16 # Specify a Docker version
  services:
    - docker:20.10.16-dind
  before_script:
    # $CI_REGISTRY_USER, $CI_REGISTRY_PASSWORD, $CI_REGISTRY are predefined GitLab CI/CD variables
    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY
    # For Docker Hub, you would use:
    # - docker login -u "$DOCKER_HUB_USERNAME" -p "$DOCKER_HUB_PASSWORD"
  script:
    # Assumes Dockerfile is in Src/deploy/ relative to the repo root
    - echo "Building Docker image from Src/deploy..."
    - docker build -t $FULL_IMAGE_NAME -f Src/deploy/Dockerfile Src/deploy
    - echo "Pushing Docker image to $FULL_IMAGE_NAME..."
    - docker push $FULL_IMAGE_NAME
  rules:
    - if: $CI_COMMIT_BRANCH
      exists:
        - Src/deploy/Dockerfile # Only run if Dockerfile exists in the specified path

# Example of combining model stages, or you can keep them separate
# as per your original list.
model_processing_pipeline:
  stage: model_processing
  # This job could coordinate multiple model steps or be broken into individual jobs:
  # model1, ocr_classification, model3, model4
  # For simplicity, one example job is shown.
  # If these models run *inside* your app's container:
  # image: $FULL_IMAGE_NAME 
  # script:
  #   - python Src/deploy/processing/run_model1.py
  #   - python Src/deploy/processing/run_ocr.py 
  #   ...
  # If they are independent or use different environments:
  image: alpine:latest # Placeholder
  script:
    - echo "Running Model 1 (placeholder)..."
    - echo "Running Model 3 (placeholder)..."
    - echo "Running Model 4 (placeholder)..."

ocr_classification_test:
  stage: model_processing # Or its own stage like 'ocr_classification'
  image: python:3.10
  allow_failure: true # As per your original config
  script:
    - echo "Preparing OCR Classification model preload test..."
    - |
      if [ -d "Src/Model/OCR_Classification/Model" ]; then
        cd Src/Model/OCR_Classification/Model
        pip install --upgrade pip
        echo "Pip upgraded."
        if [ -f "requirements.txt" ]; then
          pip install -r requirements.txt
          echo "Running classification test (test_model.py)..."
          python test_model.py
        else
          echo "requirements.txt not found in Src/Model/OCR_Classification/Model. Skipping pip install and test."
        fi
      else
        echo "Directory Src/Model/OCR_Classification/Model not found. Skipping OCR classification test."
      fi

application_tests:
  stage: test
  image: $FULL_IMAGE_NAME # Run tests inside the built application container
  script:
    - echo "Running application tests inside the container..."
    # Example: Assuming you have a test suite in your application.
    # This could be running pytest, unittest, or custom test scripts.
    # - pip install pytest # If not already in the image and needed
    # - pytest Src/deploy/tests/
    # For now, a simple check that the app starts (requires curl in the image or use a different image for testing)
    # If your image is minimal and doesn't have curl:
    # - echo "Test placeholder: Verify application health or run unit tests."
    # If your app image has curl:
    # - apk add curl --no-cache # If base image is alpine and curl is not there
    # - python Src/deploy/app.py & # Start app in background
    # - sleep 5 # Give it time to start
    # - curl http://localhost:5001 # Check if it responds
  needs: [build_application_image] # Ensure image is built before testing

deploy_application:
  stage: deploy
  image: alpine:latest # Or an image with kubectl/helm for Kubernetes, or appropriate tools for your target
  script:
    - echo "Deploying application from image $FULL_IMAGE_NAME..."
    # This script is highly dependent on your deployment target (e.g., server, Kubernetes, PaaS).
    # Example for a simple Docker run on a server (requires SSH setup and variables like $DEPLOY_SERVER, $SSH_USER, $SSH_PRIVATE_KEY):
    # - apk add --no-cache openssh-client
    # - eval $(ssh-agent -s)
    # - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    # - mkdir -p ~/.ssh
    # - chmod 700 ~/.ssh
    # - ssh-keyscan $DEPLOY_SERVER >> ~/.ssh/known_hosts
    # - chmod 644 ~/.ssh/known_hosts
    # - >
    #   ssh $SSH_USER@$DEPLOY_SERVER "
    #   docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY && \
    #   docker pull $FULL_IMAGE_NAME && \
    #   docker stop document-processor-container || true && \
    #   docker rm document-processor-container || true && \
    #   docker run -d --name document-processor-container -p 5001:5001 \
    #   -v /path/on/server/outputs:/app/outputs \
    #   -v /path/on/server/models:/app/models \
    #   $FULL_IMAGE_NAME
    #   "
    - echo "Deployment script placeholder. Customize for your environment."
  environment:
    name: production # Or staging, development, etc.
  rules:
    # Example: Only deploy from the main/master branch
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH 
  needs: [build_application_image, application_tests] # Ensure image is built and tests pass

```

### Explanation of `.gitlab-ci.yml`

-   **`stages`**: Defines the order of execution for jobs. The stages are `build_docs`, `build_app_image`, `model_processing` (which can include your `model1`, `ocr_classification`, `model3`, `model4`), `test`, and `deploy`.
-   **`variables`**:
    -   `IMAGE_NAME`, `IMAGE_TAG`, `FULL_IMAGE_NAME`: Construct the full Docker image name using GitLab's predefined CI/CD variables for its container registry.
-   **`build_documentation`**:
    -   Builds LaTeX documents from the `Documentation` directory.
    -   Includes checks for directory and `.tex` file existence.
-   **`build_application_image`**:
    -   Uses `docker:20.10.16` image with `docker:20.10.16-dind` (Docker-in-Docker) service to build Docker images.
    -   Logs into the GitLab Container Registry.
    -   Builds your application's Docker image from `Src/deploy/Dockerfile`.
    -   Pushes the built image to the GitLab Container Registry.
    -   `rules`: This job only runs if `Src/deploy/Dockerfile` exists.
-   **`model_processing_pipeline` / `ocr_classification_test`**:
    -   These are examples of how you might structure your model-related jobs.
    -   `model_processing_pipeline` is a placeholder; you can break it down into `model1`, `model3`, `model4` jobs as in your original list, specifying appropriate images and scripts.
    -   `ocr_classification_test` is adapted from your example, assuming the test script and its dependencies are in `Src/Model/OCR_Classification/Model/`. It includes checks for directory and `requirements.txt` existence.
-   **`application_tests`**:
    -   Runs tests against your application using the Docker image built in the `build_application_image` stage (`$FULL_IMAGE_NAME`).
    -   You'll need to add your actual test commands (e.g., `pytest`, API checks with `curl`).
    -   `needs: [build_application_image]` ensures this job runs after the image is successfully built.
-   **`deploy_application`**:
    -   Deploys your application. The `script` section is a placeholder and needs to be customized for your specific deployment environment (e.g., a server running Docker, Kubernetes, a cloud platform).
    -   It uses the `$FULL_IMAGE_NAME` to pull and run the correct version of your application.
    -   `environment`: Specifies the deployment environment (e.g., `production`).
    -   `rules`: Example rule to only deploy from the default branch (e.g., `main` or `master`).
    -   `needs: [build_application_image, application_tests]` ensures this job runs after the image is built and tests have passed.

### Setting up GitLab CI/CD Variables

If you are using a private Docker registry (other than GitLab's own integrated registry), or if your deployment scripts need credentials (like SSH keys for a server, or specific API keys), you'll need to configure CI/CD variables in your GitLab project's settings:
Go to **Settings > CI/CD > Variables**.

Common variables you might need to set:
-   `DOCKER_HUB_USERNAME`, `DOCKER_HUB_PASSWORD`: If pushing to Docker Hub instead of GitLab's registry.
-   `SSH_PRIVATE_KEY`, `DEPLOY_SERVER`, `SSH_USER`: If deploying to a server via SSH (as shown in the placeholder deployment script). Make sure to set `SSH_PRIVATE_KEY` as a "File" type variable if it's multi-line, or ensure newlines are handled correctly if it's a "Variable" type.

Remember to adapt the paths and commands in the `.gitlab-ci.yml` file to match your project's exact structure and requirements.
